# Controller 模块

此模块是 MVC 架构中的 **控制器（Controller）**，扮演着模型（Model）和视图（View）之间的"交通警察"或"胶水"角色。它不处理具体的数据（模型的工作）或用户界面（视图的工作），而是协调两者，确保整个应用程序正确响应用户操作。

## 功能概述

- **模型视图协调**: 连接数据模型与用户界面，实现双向数据绑定
- **事件处理**: 处理用户交互事件，将其转换为相应的业务操作
- **业务流程控制**: 管理应用程序的整体业务流程和状态转换
- **外部服务集成**: 集成AI服务、云同步等外部功能

## 文件列表及功能

### `app_controller.py`
- **核心类**: `AppController`
- **主要功能**:
  - 应用程序总指挥，协调所有组件
  - 绑定模型与视图，建立数据连接
  - 处理用户交互信号（添加、删除、修改任务等）
  - 集成计时器、AI解析、云同步功能
- **信号处理**:
  - `add_item_requested`: 添加新任务
  - `delete_item_requested`: 删除任务
  - `toggle_item_requested`: 切换任务状态
  - `ai_parse_requested`: AI智能解析
  - 云同步相关信号

### `timer_controller.py`
- **核心类**: `TimerController`
- **主要功能**:
  - 番茄钟计时器的核心控制逻辑
  - 管理计时器状态（开始、暂停、停止）
  - 处理计时完成后的通知和事件记录
  - 集成计时器界面组件
- **依赖处理器**:
  - `NotificationHandler`: 系统通知处理
  - `TimerEventHandler`: 事件记录处理

### `notification_handler.py`
- **核心类**: `NotificationHandler`
- **主要功能**:
  - 跨平台系统通知发送
  - 支持多种通知方式（notify-send、Qt托盘、终端输出）
  - 声音提醒播放
  - 优雅的降级处理机制

### `timer_event_handler.py`
- **核心类**: `TimerEventHandler`
- **主要功能**:
  - 处理番茄钟事件记录对话框
  - 管理事件数据的保存和统计
  - 与主窗口的交互协调

### `ai_parse_handler.py`
- **核心类**: `AIParseHandler`
- **主要功能**:
  - AI智能解析功能的控制逻辑
  - 集成Gemini AI服务
  - 处理解析结果并转换为待办事项
  - 错误处理和降级机制

### `cloud_sync_handler.py`
- **核心类**: `CloudSyncHandler`
- **主要功能**:
  - 云同步功能的控制逻辑
  - 处理上传和下载请求
  - 管理同步状态和错误处理

### `dialog_manager.py`
- **核心类**: `DialogManager`
- **主要功能**:
  - 管理各种对话框的显示
  - 统一对话框的样式和行为
  - 提供通用的对话框操作接口

## MVC 协同工作流程示例

以 **"用户添加一个新的待办事项"** 为例，看各模块如何协同工作：

1. **视图 (View)**: 用户在 `MainWindow` 的输入框中输入文字，然后按回车键。
   - `main_window.py` 内部的 `input_lineedit` 控件发出 `returnPressed` 信号。
   - `MainWindow` 捕获此信号，并调用自己的 `_on_add_item` 方法。
   - 该方法随即发射一个更高级别的信号 `add_item_requested`，并附带用户输入的文本。视图的工作到此结束，它不知道接下来会发生什么。

2. **控制器 (Controller)**: `AppController` 一直在监听 `add_item_requested` 信号。
   - 当信号到达时，`AppController` 中对应的处理方法被触发。
   - 控制器调用 **模型** 的 `model.add_item(text)` 方法，将用户的请求和数据传递给模型。

3. **模型 (Model)**: `TodoModel` 接收到 `add_item` 的调用。
   - 它执行业务逻辑：将新数据处理并添加到内部的 `todo_items` 列表中。
   - 在列表更新前后，它会发射 `beginInsertRows` 和 `endInsertRows` 信号。这是 Qt 模型/视图框架的标准做法。

4. **视图 (View) 自动更新**:
   - `MainWindow` 中的 `QListView` 因为已经和 `TodoModel` 绑定，所以它会自动接收到 `rowsInserted` 信号。
   - `QListView` 知道数据已更新，因此它会重新查询模型获取新数据，并请求 `TodoDelegate` 来绘制新的列表项。

这个流程完美地展示了 **关注点分离** 的原则：视图只管显示和采集用户输入，模型只管处理数据和业务规则，而控制器则负责协调它们之间的通信。

## 设计模式

### 单例模式
- `AppController` 作为应用程序的主控制器，通常只有一个实例

### 观察者模式
- 通过Qt信号槽机制实现观察者模式
- 控制器监听视图事件，模型通知视图更新

### 策略模式
- 不同的处理器（Handler）实现不同的处理策略
- 如通知处理支持多种通知方式

### 命令模式
- 将用户操作封装为命令对象
- 支持撤销、重做等功能

## 依赖关系

### 核心依赖
- `model/`: 数据模型层，提供业务数据和逻辑
- `view/`: 视图层，提供用户界面组件
- `utils/`: 工具层，提供AI服务、数据转换等功能

### 外部依赖
- `PySide6`: Qt框架，提供信号槽机制
- `cloud/`: 云同步功能模块

## 错误处理策略

### 异常捕获
- 在控制器层统一捕获和处理异常
- 防止异常传播到视图层

### 降级处理
- AI服务不可用时降级到传统解析
- 云同步失败时保持本地功能正常

### 用户反馈
- 通过对话框向用户展示错误信息
- 提供操作建议和恢复方案

## 性能优化

### 延迟保存
- 使用定时器机制延迟保存操作
- 避免频繁的I/O操作

### 异步处理
- 网络请求和文件操作采用异步方式
- 避免阻塞用户界面

### 内存管理
- 及时释放不需要的对象引用
- 避免内存泄漏

## 测试策略

### 单元测试
- 测试各个控制器类的独立功能
- Mock外部依赖进行隔离测试

### 集成测试
- 测试控制器与模型、视图的交互
- 验证完整的用户操作流程

### 用户界面测试
- 模拟用户操作验证响应
- 测试异常情况下的界面行为 